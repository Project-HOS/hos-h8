-------------------------------------------------------------------------------
 Hyper Oparating System V3 for Hitachi H8                                      
 テクニカルドキュメント                                                        
                                                                               
                                        Copyright (C) 1998-2002 by Project HOS 
-------------------------------------------------------------------------------



  このドキュメントでは、HOS-H8 のソースを読んだり、バグを取ったり、改造したり
する人のために少しでも役立ちそうなことを書いておきます。参考になれば幸いです。



------------------------------------------------------------------------------
                             ソースのメイク
------------------------------------------------------------------------------
  ソースメイク時にマクロを宣言することで、エラーチェックを変更できます。


＜エラーチェックについて＞
  μITRONではさまざまなエラー項目が用意されていますが、極めて小さなシステム
では起こることが絶対に無いエラーをいちいちチェックするのはメモリも実行速度
も無駄となります。そこで HOS では __ERR_CHECK_LEVEL というマクロを用意しま
した。このマクロの値によってエラーチェックを外したライブラリが容易に作製で
きます。
  現バージョンでは E_QOVR, E_CTX, E_OBJ, E_ID, E_NOEXS, E_PAR の６つのエラー
に対処しております。__ERR_CHECK_LEVEL を小さい値にするほどチェックするエラー
項目が減っていきます。
  基本的に E_ID, E_NOEXS, E_PAR はプログラム時の人為的ミスでしか発生しない
と思います。デバッグ後にこれらのチェックを外せばいくらか高速になります。

4 : E_QOVR, E_OBJ, E_CTX, E_ID, E_NOEXS, E_PAR （全てチェック）
3 : E_QOVR, E_OBJ, E_CTX
2 : E_QOVR, E_OBJ
1 : E_QOVR
0 : エラーチェックなし

  なおバージョンアップによってこれらの値が変わる可能性は大いにありますので
ご注意ください。


  なお、ただでさえいい加減なデバッグは __ERR_CHECK_LEVEL=4 でしか行なって
おりません（笑）。
  テストはほとんどしてません、ごめんなさい。正常系ですら動くのやら (^^;;



------------------------------------------------------------------------------
                       ソースを読まれる方のために
------------------------------------------------------------------------------

  ソースを読まれる方のために少しだけ説明を書いておきます。


＜オブジェクトのコントロールブロック＞
  タスク、セマフォ、イベントフラグ、メイルボックスなどのオブジェクトは全て
配列で管理しています。IDに 0 はありませんので、ID - 1 が配列上の位置となり
ます。ROM化されるべき初期値と、RAM上に置かれるべき作業領域とで別々の構造体
を用意しています。またアセンブリ部からアクセスされるものについてはなるべく
構造体の先頭の方に宣言しています（計算が楽なので）。
  これらは全てコンフィギュレーターが吐くソースの中で宣言されます。

・タスクコントロールブロック(ID 1-n)
        T_TCB  tcbtbl[n];    RAM部
  const T_TCBS tcbstbl[n];   ROM部
  const H      tcbcnt = n;   TCBの個数

・セマフォコントロールブロック(ID 1-n)
        T_SCB  scbtbl[n];    RAM部
  const T_SCBS scbstbl[n];   ROM部
  const H      scbcnt = n;   SCBの個数

・イベントフラグコントロールブロック(ID 1-n)
        T_FCB  fcbtbl[n];    RAM部
  const T_FCBS fcbstbl[n];   ROM部
  const H      fcbcnt = n;   FCBの個数

・メイルボックスコントロールブロック(ID 1-n)
        T_MCB  mcbtbl[n];    RAM部
  const T_MCBS mcbstbl[n];   ROM部
  const H      mcbcnt = n;   MCBの個数

・スタックプールコントロールブロック(ID 1-n)
        T_SPCB  spcbtbl[1];  RAM部
  const T_SPCBS spcbstbl[1]; ROM部
  const H       spcbcnt;     SPBの個数

  サイズについてはあまり考慮していませんが、2^n にすると高速化されるかも
知れません。exinf など必要無ければ省けばサイズの縮小になります。なお属性
(tskatrとか)の項目はありません。コプロはありませんし、ルーチンは全てＣ言語
とみなします。



＜レディーキュー＞
  レディーキューもコンフィギュレーターが出力します。優先度の数だけキューを
作りますので、必要な分だけをここで確保します。

  T_QUE rdyque[8];   レディーキュー (TSKPRI - 1 に対応)
  UB    rdqcnt = 8;  最大優先度

  レディーキューには RUN 状態のタスクも SUSPEND状態のタスクも接続します。
高優先度のキューからREADY状態のタスクを探していき最初に見つけたタスクが
現在のタスク（curtcbが指すタスク)で無ければディスパッチが遅延されていると
見なせます。


＜システムの状態 sysstat＞
  現在の状態を表すために sysstat というグローバル変数があります。この変数に
よってタスク部／非タスク部、ディスパッチの許可／不許可を管理します。


＜現在のタスク curtcb＞
  現在実行中のタスクの TCB を指す変数として curtcb があります。


＜遅延ディスパッチフラグ dlydsp＞
  ディスパッチ禁止中にディスパッチの要求があるとこのフラグを TRUE にします。
ディスパッチが許可された時点でこのフラグが TRUE であるとレディーキューの
先頭タスクにディスパッチしてフラグを FALSE にします。


＜関数名・変数名＞
  ＯＳが内部で使っている関数についてはアンダースコア２つ "__" から始めるよう
にしていますが、変数については特に規則を設けていません。ＯＳ自体をオブジェクト
化しているのでこれらは static 属性にはなっていません。アプリケーション側で同じ
名前の変数を定義すると衝突してしまうので注意してください。
